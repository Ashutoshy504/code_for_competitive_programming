/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Duc
 */

#include <iostream>
#include <fstream>

#define C11

#ifdef SUBMIT
#define LOGLEVEL 0
#define NDEBUG
#else
#define LOGLEVEL 1
#endif

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cassert>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <iomanip>
#include <queue>
#include <stack>
#include <functional>
#include <sstream>
#include <deque>
#include <climits>
#include <cfloat>
#include <bitset>

#ifdef C11

#include <array>
#include <type_traits>
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <memory>

#endif

#define LOG(l, x) if (l <= LOGLEVEL) cout << x << endl

#define int64 long long
#define repeat(x) for (auto repeat_var = 0; repeat_var < x; ++repeat_var)

#define for_inc(i, x) for (auto i = 0; i < x; ++i)
#define for_dec(i, x) for (auto i = x - 1; i >= 0; --i)
#define for_inc_range(i, x, y) for (auto i = x; i <= y; ++i)
#define for_dec_range(i, x, y) for (auto i = x; i >= y; --i)

#define countBit __builtin_popcount
#define countBit64 __builtin_popcountl

#define fill0(x) memset(x, 0, sizeof(x))
#define INT_INF ((int)2E9L)
#define INT64_INF ((int64)1E18L)
#define MOD 1000000007

using namespace std;

#ifndef GLOBAL_H
#define GLOBAL_H

#ifndef NDEBUG
#   define ASSERT(condition, message) \
    do { \
        if (! (condition)) { \
            std::cerr << "Assertion `" #condition "` failed in " << __FILE__ \
                      << " line " << __LINE__ << ": " << message << std::endl; \
            assert(false); \
        } \
    } while (false)
#else
#   define ASSERT(condition, message) do { } while (false)
#endif

string toYesNo(bool b) {
    return b ? "YES" : "NO";
}

#endif


#ifndef COLLECTIONS_H
#define COLLECTIONS_H

namespace cl {
    template<class K, class V>
    class Map {
        std::map<K, V> map;

        typedef typename std::map<K, V>::iterator iterator;
        typedef typename std::map<K, V>::reverse_iterator reverse_iterator;
    public:
        bool empty() {
            return map.empty();
        }

        iterator begin() {
            return map.begin();
        }

        iterator end() {
            return map.end();
        }

        reverse_iterator rbegin() {
            return map.rbegin();
        }

        reverse_iterator rend() {
            return map.rend();
        }

        K firstKey() {
            assert(!empty());
            return begin()->first;
        }

        V firstValue() {
            assert(!empty());
            return begin()->second;
        }

        K lastKey() {
            assert(!empty());
            return map.rbegin()->first;
        }

        V lastValue() {
            assert(!empty());
            return map.rbegin()->second;
        }

        void removeLast() {
            map.erase(lastKey());
        }

        void removeFirst() {
            map.erase(firstKey());
        }

        V &operator[](const K &k) {
            return map[k];
        }
    };

    template<class V>
    class Array {
        std::vector<V> vec;

        typedef typename std::vector<V>::iterator iterator;
        typedef typename std::vector<V>::const_iterator const_iterator;

    public:
        Array() { }

        Array(int sz) : vec(vector<V>(sz)) { }

        void resize(int sz) {
            vec.resize(sz);
        }

        void assertIndex(int index) const {
            ASSERT(index >= 0 && index < vec.size(), "Index of out bounds, size = " << size() << ", index = " << index);
        }

        V &operator[](int index) {
            assertIndex(index);
            return vec[index];
        }

        const V &operator[](int index) const {
            assertIndex(index);
            return vec[index];
        }

        /**
         * Return the new index
         */
        int add(const V &v) {
            vec.push_back(v);
            return vec.size() - 1;
        }

        iterator begin() {
            return vec.begin();
        }

        const_iterator begin() const {
            return vec.begin();
        }

        iterator end() {
            return vec.end();
        }

        const_iterator end() const {
            return vec.end();
        }

        int size() const {
            return vec.size();
        }

        V &last() {
            return this[size() - 1];
        }

        V &first() {
            return this[0];
        }

        bool empty() {
            return size() == 0;
        }

        friend std::ostream &operator<<(std::ostream &stream, const Array<V> &array) {
            bool first = true;
            stream << "Array of " << array.size() << ": [";
            for (auto &v : array) {
                if (!first) {
                    stream << ", ";
                }
                first = false;
                stream << v;
            }
            stream << "]";
            return stream;
        }
    };

    /**
     * 1 based array
     */
    template<class V>
    class Array1 : public Array<V> {
    public:
        Array1() { }

        Array1(int sz) : Array<V>(sz) { }

        V &operator[](int index) {
            return Array<V>::operator[](index - 1);
        }

        const V &operator[](int index) const {
            return Array<V>::operator[](index - 1);
        }
    };

    /**
     * Range based array
     */
    template<class V>
    class ArrayR : public Array<V> {
        int minIndex, maxIndex;
    public:
        ArrayR() { }

        ArrayR(int minIndex, int maxIndex) : Array<V>(maxIndex - minIndex + 1), minIndex(minIndex), maxIndex(maxIndex) {
            assert(minIndex <= maxIndex);
            assert(Array<V>::size() == (maxIndex - minIndex + 1));
        }

        V &operator[](int index) {
            return Array<V>::operator[](index - minIndex);
        }

        const V &operator[](int index) const {
            return Array<V>::operator[](index - minIndex);
        }
    };
}

#endif


#ifndef MATH_H
#define MATH_H

namespace math {
// Compute a^n in log(n)
    template<class T>
    T power(const T &a, int n) {
        assert(n >= 1);
        if (n == 1) {
            return a;
        } else if (n % 2 == 0) {
            T tmp = power(a, n / 2);
            return tmp * tmp;
        } else {
            return a * power(a, n - 1);
        }
    }

    template<class T>
    class DefaultCalculator {
    public:
        static T zero() {
            return 0;
        }

        static T plus(const T &a, const T &b) {
            return a + b;
        }

        static T multiply(const T &a, const T &b) {
            return a * b;
        }

        static T subtract(const T &a, const T &b) {
            return a - b;
        }

        static T divide(const T &a, const T &b) {
            return a / b;
        }
    };

}

#endif

#ifndef MATRIX_H
#define MATRIX_H

template<class T, class Calc = math::DefaultCalculator<T>>
class Matrix {
    cl::Array1<cl::Array1<T>> a;
    int nRow, nCol;
public:
    void init(int nRow, int nCol) {
        this->nRow = nRow;
        this->nCol = nCol;
        a.resize(nRow);
        for_inc_range(r, 1, nRow) {
            a[r].resize(nCol);
            for_inc_range(c, 1, nCol) {
                a[r][c] = Calc::zero();
            }
        }
    }

    void init(int nRow, int nCol, const cl::Array1<cl::Array1<T>> &val) {
        assert(val.size() == nRow);
        assert(val[1].size() == nCol);
        init(nRow, nCol);
        for_inc_range(r, 1, nRow) {
            for_inc_range(c, 1, nCol) {
                a[r][c] = val[r][c];
            }
        }
    }

    void init(const cl::Array1<cl::Array1<T>> &val) {
        init(val.size(), val[1].size(), val);
    }

    Matrix &operator=(const cl::Array1<cl::Array1<T>> &val) {
        init(val);
        return *this;
    }

    Matrix operator+(const Matrix &o) const {
        assert(nRow == o.nRow);
        assert(nCol == o.nCol);
        Matrix ret;
        ret.init(nRow, nCol);
        for_inc_range(r, 1, nRow) for_inc_range(c, 1, nCol) ret.a[r][c] = Calc::plus(a[r][c], o.a[r][c]);
        return ret;
    }

    Matrix operator*(const Matrix &o) const {
        assert(nCol == o.nRow);
        Matrix ret;
        ret.init(nRow, o.nCol);
        for_inc_range(r, 1, nRow) for_inc_range(c2, 1, nCol) if (a[r][c2] != Calc::zero())
                    for_inc_range(c, 1, o.nCol) {
                        ret.a[r][c] = Calc::plus(ret.a[r][c], Calc::multiply(a[r][c2], o.a[c2][c]));
                    }
        return ret;
    }

    Matrix power(int k) const {
        return math::power(*this, k);
    }

    cl::Array1<T> &operator[](int r) {
        return a[r];
    }

    friend std::ostream &operator<<(std::ostream &stream, const Matrix &matrix) {
        stream << "[matrix: row = " << matrix.nRow << ", col = " << matrix.nCol << endl;
        for_inc_range(r, 1, matrix.nRow) {
            for_inc_range(c, 1, matrix.nCol) {
                stream << matrix.a[r][c] << " ";
            }
            stream << endl;
        }
        stream << "]" << endl;
        return stream;
    }
};

template<class T, class Calc = math::DefaultCalculator<T>>
class UpperTriMatrix {
    cl::Array1<cl::ArrayR<T>> a;
    int size;
public:
    void init(int size) {
        this->size = size;
        this->size = size;
        a.resize(size);
        for_inc_range(r, 1, size) {
            a[r] = cl::ArrayR<T>(r, size);
            for_inc_range(c, r, size) {
                a[r][c] = Calc::zero();
            }
        }
    }

    UpperTriMatrix operator+(const UpperTriMatrix &o) const {
        assert(size == o.size);
        UpperTriMatrix ret;
        ret.init(size);
        for_inc_range(r, 1, size) for_inc_range(c, r, size) ret.a[r][c] = Calc::plus(a[r][c], o.a[r][c]);
        return ret;
    }

    UpperTriMatrix operator*(const UpperTriMatrix &o) const {
        assert(size == o.size);
        UpperTriMatrix ret;
        ret.init(size);
        for_inc_range(r, 1, size) for_inc_range(c2, r, size) if (a[r][c2] != Calc::zero())
                    for_inc_range(c, c2, size) {
                        ret.a[r][c] = Calc::plus(ret.a[r][c], Calc::multiply(a[r][c2], o.a[c2][c]));
                    }
        return ret;
    }

    UpperTriMatrix power(int k) const {
        return math::power(*this, k);
    }

    cl::ArrayR<T> &operator[](int r) {
        return a[r];
    }

    friend std::ostream &operator<<(std::ostream &stream, const UpperTriMatrix &matrix) {
        stream << "[UpperTriMatrix: size = " << matrix.size << endl;
        for_inc_range(r, 1, matrix.size) {
            for_inc_range(c, r, matrix.size) {
                stream << matrix.a[r][c] << " ";
            }
            stream << endl;
        }
        stream << "]" << endl;
        return stream;
    }
};

#endif


class MyCalc {
public:
    static inline int zero() {
        return -1E9L;
    }

    static inline int plus(const int &a, const int &b) {
        return max(a, b);
    }

    static inline int multiply(const int &a, const int &b) {
        return a + b;
    }
};

class TaskB {
public:
    void solve(std::istream &in, std::ostream &out) {
        int n, nRepeat;
        in >> n >> nRepeat;
        cl::Array1<int> a(n);
        int maxVal = 0;

        for_inc_range(i, 1, n) {
            in >> a[i];
            maxVal = max(maxVal, a[i]);
        }

        UpperTriMatrix<int, MyCalc> base;
        base.init(maxVal);

        for_inc_range(lower, 1, maxVal)
            for_inc_range(upper, lower, maxVal) {
                base[lower][upper] = 0;
            }

        for_inc_range(lower, 1, maxVal) {
            cl::Array1<int> longestEnd(n);

            for_inc_range(i, 1, n) if (a[i] >= lower) {
                    longestEnd[i] = 1;
                    for_inc_range(j, 1, i - 1) {
                        if (a[j] >= lower && a[j] <= a[i]) {
                            longestEnd[i] = max(longestEnd[i], longestEnd[j] + 1);
                        }
                    }
                }

            for_inc_range(i, 1, n) if (a[i] >= lower) {
                    for_inc_range(upper, a[i], maxVal) {
                        base[lower][upper] = MyCalc::plus(base[lower][upper], longestEnd[i]);
                    }
                }
        }

        base = base.power(nRepeat);

        int best = 0;
        for_inc_range(lower, 1, maxVal) {
            for_inc_range(upper, lower, maxVal) {
                best = MyCalc::plus(best, base[lower][upper]);
            }
        }

        out << best << endl;
    }
};


int main() {
    TaskB solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}
