/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Duc
 */

#include <iostream>
#include <fstream>

#define C11

#ifdef SUBMIT
#define LOGLEVEL 0
#define NDEBUG
#else
#define LOGLEVEL 1
#endif

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cassert>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <iomanip>
#include <queue>
#include <stack>
#include <functional>
#include <sstream>
#include <deque>
#include <climits>
#include <cfloat>
#include <bitset>

#ifdef C11

#include <array>
#include <type_traits>
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <memory>

#endif

#define LOG(l, x) if (l <= LOGLEVEL) cout << x << endl

#define int64 long long
#define repeat(x) for (auto repeat_var = 0; repeat_var < x; ++repeat_var)

#define for_inc(i, x) for (auto i = 0; i < x; ++i)
#define for_dec(i, x) for (auto i = x - 1; i >= 0; --i)
#define for_inc_range(i, x, y) for (auto i = x; i <= y; ++i)
#define for_dec_range(i, x, y) for (auto i = x; i >= y; --i)

#define countBit __builtin_popcount
#define countBit64 __builtin_popcountl

#define fill0(x) memset(x, 0, sizeof(x))
#define INT_INF ((int)2E9L)
#define INT64_INF ((int64)1E18L)
#define MOD 1000000007

using namespace std;

#ifndef GLOBAL_H
#define GLOBAL_H

string toYesNo(bool b) {
    return b ? "YES" : "NO";
}

#endif


#ifndef ITERATOR_H
#define ITERATOR_H

template<class T>
class Iterator {
public:
    virtual bool hasNext() const = 0;

    virtual T next() = 0;
};

template<class T>
class Iterable {
public:
    virtual unique_ptr<Iterator<T>> iterator() const = 0;
};


template<class T, class UnaryPredicate>
bool any(const Iterable<T> &iterable, const UnaryPredicate &pred) {
    auto it = iterable.iterator();
    while (it->hasNext()) {
        if (pred(it->next())) {
            return true;
        }
    }
    return false;
}

template<class T, class UnaryPredicate>
bool all(const Iterable<T> &iterable, const UnaryPredicate &pred) {
    auto it = iterable.iterator();
    while (it->hasNext()) {
        if (!pred(it->next())) {
            return false;
        }
    }
    return true;
}

template<class T>
bool unique(const Iterable<T> &iterable) {
    auto it = iterable.iterator();
    bool first = true;
    T val;
    while (it->hasNext()) {
        T x = it->next();
        if (first) {
            val = x;
            first = false;
        } else {
            if (val != x) {
                return false;
            }
        }
    }
    return true;
}

template<class IN, class OUT>
class MapIterator : public Iterator<OUT> {
    unique_ptr<Iterator<IN>> in;
    const function<OUT(IN)> &mapper;

public:
    MapIterator(unique_ptr<Iterator<IN>> in, const function<OUT(IN)> &mapper) : in(move(in)), mapper(mapper) { }

    virtual bool hasNext() const {
        return in->hasNext();
    }

    virtual OUT next() {
        return mapper(in->next());
    }
};

template<class IN, class OUT>
class MapIterable : public Iterable<OUT> {
    const Iterable<IN> &in;
    const function<OUT(IN)> &mapper;
public:
    MapIterable(const Iterable<IN> &in, const function<OUT(IN)> &mapper) : in(in), mapper(mapper) { }

    virtual unique_ptr<Iterator<OUT>> iterator() const {
        return unique_ptr<Iterator<OUT>>(new MapIterator<IN, OUT>(in.iterator(), mapper));
    }
};

template<class IN, class OUT>
MapIterable<IN, OUT> mapIterable(const Iterable<IN> &iterable, const function<OUT(IN)> &mapper) {
    return MapIterable<IN, OUT>(iterable, mapper);
}

template<class T>
class FilterIterator : public Iterator<T> {
    unique_ptr<Iterator<T>> in;
    const function<bool(T)> &pred;
    T nextElement;
    bool hasNextElement;

    void findNext() {
        hasNextElement = false;
        while (in->hasNext()) {
            nextElement = in->next();
            if (pred(nextElement)) {
                hasNextElement = true;
                break;
            }
        }
    }

public:
    FilterIterator(unique_ptr<Iterator<T>> in, const function<bool(T)> &pred) : in(move(in)), pred(pred) {
        findNext();
    }

    virtual bool hasNext() const {
        return hasNextElement;
    }

    virtual T next() {
        T ret = nextElement;
        findNext();
        return ret;
    }
};

template<class T>
class FilterIterable : public Iterable<T> {
    const Iterable<T> &in;
    const function<bool(T)> &pred;
public:
    FilterIterable(const Iterable<T> &in, const function<bool(T)> &pred) : in(in), pred(pred) { }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new FilterIterator<T>(in.iterator(), pred));
    }
};

template<class T>
FilterIterable<T> filter(const Iterable<T> &iterable, const function<bool(T)> &filter) {
    return FilterIterable<T>(iterable, filter);
}

template<class IN1, class IN2, class OUT>
class ProductIterator : public Iterator<OUT> {
    const Iterable<IN1> &in1;
    const Iterable<IN2> &in2;

    unique_ptr<Iterator<IN1>> in1Iter;
    unique_ptr<Iterator<IN2>> in2Iter;
    const function<OUT(IN1, IN2)> &mapper;
    IN1 cur1;
    IN2 cur2;
    OUT nextElement;
    bool hasNextElement;

    void findNext() {
        if (in2Iter->hasNext()) {
            cur2 = in2Iter->next();
            nextElement = mapper(cur1, cur2);
            hasNextElement = true;
        } else {
            if (in1Iter->hasNext()) {
                cur1 = in1Iter->next();
                in2Iter = in2.iterator();
                findNext();
            } else {
                hasNextElement = false;
            }
        }
    }

public:
    ProductIterator(const Iterable<IN1> &in1, const Iterable<IN2> &in2, const function<OUT(IN1, IN2)> &mapper) : in1(
            in1), in2(in2), mapper(mapper) {
        in1Iter = in1.iterator();
        if (in1Iter->hasNext()) {
            cur1 = in1Iter->next();
            in2Iter = in2.iterator();
            findNext();
        } else {
            hasNextElement = false;
        }
    }

    virtual bool hasNext() const {
        return hasNextElement;
    }

    virtual OUT next() {
        OUT ret = nextElement;
        findNext();
        return ret;
    }
};

template<class IN1, class IN2, class OUT>
class ProductIterable : public Iterable<OUT> {
    const Iterable<IN1> &in1;
    const Iterable<IN2> &in2;
    const function<OUT(IN1, IN2)> &mapper;
public:
    ProductIterable(const Iterable<IN1> &in1, const Iterable<IN2> &in2, const function<OUT(IN1, IN2)> &mapper) : in1(
            in1), in2(in2), mapper(mapper) { }

    virtual unique_ptr<Iterator<OUT>> iterator() const {
        return unique_ptr<Iterator<OUT>>(new ProductIterator<IN1, IN2, OUT>(in1, in2, mapper));
    }
};

template<class IN1, class IN2, class OUT>
ProductIterable<IN1, IN2, OUT> product(const Iterable<IN1> &in1, const Iterable<IN2> &in2,
                                       const function<OUT(IN1, IN2)> &mapper) {
    return ProductIterable<IN1, IN2, OUT>(in1, in2, mapper);
}

template<class T, class ITERATOR>
class StdIterator : public Iterator<T> {
    const ITERATOR &begin, &end;
    ITERATOR it;

public:
    StdIterator(const ITERATOR &begin, const ITERATOR &end) : begin(begin), end(end), it(begin) { }

    virtual bool hasNext() const {
        return it != end;
    }

    virtual T next() {
        T ret = *it;
        it++;
        return ret;
    }
};

template<class T, class ITERATOR>
class StdIterable : public Iterable<T> {
    const ITERATOR &begin, &end;
public:
    StdIterable(const ITERATOR &begin, const ITERATOR &end) : begin(begin), end(end) { }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new StdIterator<T, ITERATOR>(begin, end));
    }
};

template<class T, class ITERATOR>
StdIterable<T, ITERATOR> stdIterable(const ITERATOR &begin, const ITERATOR &end) {
    return StdIterable<T, ITERATOR>(begin, end);
};

template<class T>
T aggregate(const Iterable<T> &iterable, const function<T(T, T)> &aggregator) {
    auto it = iterable.iterator();
    bool first = true;
    T ret;
    while (it->hasNext()) {
        if (first) {
            ret = it->next();
            first = false;
        } else {
            ret = aggregator(ret, it->next());
        }
    }
    return ret;
}

template<class T>
vector<T> collect(const Iterable<T> &iterable) {
    auto it = iterable.iterator();
    vector<T> vec;
    while (it->hasNext()) {
        vec.push_back(it->next());
    }
    return vec;
}


template<class T>
void forEach(const Iterable<T> &iterable, const function<void(T)> &f) {
    auto it = iterable.iterator();
    while (it->hasNext()) {
        f(it->next());
    }
}

template<class T>
void printInterable(const Iterable<T> &iterable) {
    auto it = iterable.iterator();
    while (it->hasNext()) {
        LOG(1, it->next() << " ");
    }
    LOG(1, endl);
}

template<class T>
T aggregateMax(const Iterable<T> &iterable) {
    return aggregate<T>(iterable, [](const T &a, const T &b) { return max(a, b); });
}

template<class T>
T aggregateSum(const Iterable<T> &iterable) {
    return aggregate<T>(iterable, [](const T &a, const T &b) { return a + b; });
}

template<class T> using predicate = function<bool(T)>;

#endif


/**
 * O(N)
 */
template<class T>
void maximumSumContiguousSubsequence(const Iterable<T> &seq, T &result) {
    auto it = seq.iterator();
    bool has = false;
    T sum;
    while (it->hasNext()) {
        auto val = it->next();
        if (!has) {
            has = true;
            result = sum = val;
        } else {
            sum = ((sum > 0) ? sum : 0) + val;
            result = max(result, sum);
        }
    }
}

template<class T>
void minimumSumContiguousSubsequence(const Iterable<T> &seq, T &result) {
    auto it = seq.iterator();
    bool has = false;
    T sum;
    while (it->hasNext()) {
        auto val = it->next();
        if (!has) {
            has = true;
            result = sum = val;
        } else {
            sum = ((sum < 0) ? sum : 0) + val;
            result = min(result, sum);
        }
    }
}


/*
 * Used to find min(x | predicate(x)), if predicate(x) is .. 0, 0, 0, 1, 1, 1, ...
 */
template<class T>
bool binarySearchMin(const T &minIndex, const T &maxIndex, const function<bool(T)> &predicate, T &result) {
    T leftIndex = minIndex, rightIndex = maxIndex, midIndex, ret = maxIndex + 1;
    while (leftIndex <= rightIndex) {
        midIndex = leftIndex + (rightIndex - leftIndex) / 2;
        if (predicate(midIndex)) {
            ret = midIndex;
            rightIndex = midIndex - 1;
        } else {
            leftIndex = midIndex + 1;
        }
    }
    result = ret;
    return ret != maxIndex + 1;
}

/*
 * Used to find max(x | predicate(x)), if predicate(x) is .. 1, 1, 1, 0, 0, 0, ...
 */
template<class T>
bool binarySearchMax(const T &minIndex, const T &maxIndex, const function<bool(T)> &predicate, T &result) {
    T leftIndex = minIndex, rightIndex = maxIndex, midIndex, ret = minIndex - 1;
    while (leftIndex <= rightIndex) {
        midIndex = leftIndex + (rightIndex - leftIndex) / 2;
        if (predicate(midIndex)) {
            ret = midIndex;
            leftIndex = midIndex + 1;
        } else {
            rightIndex = midIndex - 1;
        }
    }
    result = ret;
    return ret != minIndex - 1;
}

/*
 * Used to find max(x | predicate(x)), if predicate(x) is continuously .. 1, 1, 1, 0, 0, 0, ...
 */
bool binarySearchMaxReal(double minRange, double maxRange, double epsilon, const function<bool(double)> &predicate,
                         double &result) {
    double l = minRange, r = maxRange, m, ret = minRange - 1;
    while (r - l > epsilon) {
        m = l + (r - l) / 2;
        if (predicate(m)) {
            ret = m;
            l = m;
        } else {
            r = m;
        }
    }
    result = ret;
    return ret != minRange - 1;
}

/*
 * Used to find min(x | predicate(x)), if predicate(x) is continuously .. 0, 0, 0, 1, 1, 1, ...
 */
bool binarySearchMinReal(double minRange, double maxRange, double epsilon, const function<bool(double)> &predicate,
                         double &result) {
    double l = minRange, r = maxRange, m, ret = maxRange + 1;
    while (r - l > epsilon) {
        m = l + (r - l) / 2;
        if (predicate(m)) {
            r = m;
            ret = m;
        } else {
            l = m;
        }
    }
    result = ret;
    return ret != maxRange + 1;
}

/*
 * Used to find the intersection of an increasing and a deceasing function
 */
bool binarySearchIntersection(double minRange, double maxRange, double epsilon,
                              const function<double(double)> &increasing, const function<double(double)> &decreasing,
                              double &intersection) {
    return binarySearchMinReal(minRange, maxRange, epsilon, [&](double x) {
        //LOG(1, x << " " << increasing(x) << " " << decreasing(x));
        return increasing(x) >= decreasing(x);
    }, intersection);
}

int n;
vector<double> a;

function<double(double)> addFunction(double x) {
    return [x](double v) {
        return v + x;
    };
}

double increasing(double x) {
    double result;
    maximumSumContiguousSubsequence(mapIterable(stdIterable<double>(a.begin(), a.end()), addFunction(x)), result);
    return result;
}

double decreasing(double x) {
    double result;
    minimumSumContiguousSubsequence(mapIterable(stdIterable<double>(a.begin(), a.end()), addFunction(x)), result);
    return -result;
}

class TaskC {
public:
    void solve(std::istream &in, std::ostream &out) {
        in >> n;
        a.resize(n);
        for_inc(i, n) {
            in >> a[i];
        }
        double ret;
        binarySearchIntersection(-3e4, 3e4, 1e-7, increasing, decreasing, ret);
        out << setiosflags(ios::fixed) << std::setprecision(12) << min(increasing(ret), decreasing(ret)) << endl;
    }
};


int main() {
    TaskC solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}
