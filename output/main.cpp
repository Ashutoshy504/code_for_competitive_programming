/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Duc
 */

#include <iostream>
#include <fstream>

#define C11

#ifdef SUBMIT
#define LOGLEVEL 0
#define NDEBUG
#else
#define LOGLEVEL 1
#endif

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cassert>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <queue>
#include <stack>
#include <functional>
#include <sstream>
#include <deque>
#include <climits>
#include <cfloat>
#include <bitset>

#ifdef C11

#include <array>
#include <type_traits>
#include <random>
#include <unordered_set>
#include <unordered_map>
#include <memory>

#endif

#define LOG(l, x) if (l <= LOGLEVEL) cout << x << endl

#define int64 long long
#define repeat(x) for (auto repeat_var = 0; repeat_var < x; ++repeat_var)

#define for_inc(i, x) for (auto i = 0; i < x; ++i)
#define for_dec(i, x) for (auto i = x - 1; i >= 0; --i)
#define for_inc_range(i, x, y) for (auto i = x; i <= y; ++i)
#define for_dec_range(i, x, y) for (auto i = x; i >= y; --i)

#define countBit __builtin_popcount
#define countBit64 __builtin_popcountl

#define fill0(x) memset(x, 0, sizeof(x))
#define INT_INF ((int)2E9L)
#define INT64_INF ((int64)1E18L)
#define MOD 1000000007

using namespace std;

#ifndef GLOBAL_H
#define GLOBAL_H

string toYesNo(bool b) {
    return b ? "YES" : "NO";
}

#endif


#ifndef ITERATOR_H
#define ITERATOR_H

template<class T>
class Iterator {
public:
    virtual bool hasNext() const = 0;

    virtual T next() = 0;
};

template<class T>
class Iterable {
public:
    virtual unique_ptr<Iterator<T>> iterator() const = 0;
};


template<class T, class UnaryPredicate>
bool any(const Iterable<T> &iterable, const UnaryPredicate &pred) {
    auto it = iterable.iterator();
    while (it->hasNext()) {
        if (pred(it->next())) {
            return true;
        }
    }
    return false;
}

template<class T, class UnaryPredicate>
bool all(const Iterable<T> &iterable, const UnaryPredicate &pred) {
    auto it = iterable.iterator();
    while (it->hasNext()) {
        if (!pred(it->next())) {
            return false;
        }
    }
    return true;
}

template<class T>
bool unique(const Iterable<T> &iterable) {
    auto it = iterable.iterator();
    bool first = true;
    T val;
    while (it->hasNext()) {
        T x = it->next();
        if (first) {
            val = x;
            first = false;
        } else {
            if (val != x) {
                return false;
            }
        }
    }
    return true;
}

template<class IN, class OUT>
class MapIterator : public Iterator<OUT> {
    Iterator<IN> &in;
    const function<OUT(IN)> &mapper;

public:
    MapIterator(Iterator<IN> &in, const function<OUT(IN)> &mapper) : in(in), mapper(mapper) { }

    virtual bool hasNext() const {
        return in.hasNext();
    }

    virtual OUT next() {
        return mapper(in.next());
    }
};

template<class IN, class OUT>
class MapIterable : public Iterable<OUT> {
    const Iterable<IN> &in;
    const function<OUT(IN)> &mapper;
public:
    MapIterable(const Iterable<IN> &in, const function<OUT(IN)> &mapper) : in(in), mapper(mapper) { }

    virtual unique_ptr<Iterator<OUT>> iterator() const {
        return unique_ptr<Iterator<OUT>>(new MapIterator<IN, OUT>(*in.iterator(), mapper));
    }
};

template<class IN, class OUT>
MapIterable<IN, OUT> mapIterable(const Iterable<IN> &iterable, const function<OUT(IN)> &mapper) {
    return MapIterable<IN, OUT>(iterable, mapper);
}

template<class T>
class FilterIterator : public Iterator<T> {
    unique_ptr<Iterator<T>> in;
    const function<bool(T)> &pred;
    T nextElement;
    bool hasNextElement;

    void findNext() {
        hasNextElement = false;
        while (in->hasNext()) {
            nextElement = in->next();
            if (pred(nextElement)) {
                hasNextElement = true;
                break;
            }
        }
    }

public:
    FilterIterator(unique_ptr<Iterator<T>> in, const function<bool(T)> &pred) : in(move(in)), pred(pred) {
        findNext();
    }

    virtual bool hasNext() const {
        return hasNextElement;
    }

    virtual T next() {
        T ret = nextElement;
        findNext();
        return ret;
    }
};

template<class T>
class FilterIterable : public Iterable<T> {
    const Iterable<T> &in;
    const function<bool(T)> &pred;
public:
    FilterIterable(const Iterable<T> &in, const function<bool(T)> &pred) : in(in), pred(pred) { }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new FilterIterator<T>(in.iterator(), pred));
    }
};

template<class T>
FilterIterable<T> filter(const Iterable<T> &iterable, const function<bool(T)> &filter) {
    return FilterIterable<T>(iterable, filter);
}

template<class IN1, class IN2, class OUT>
class ProductIterator : public Iterator<OUT> {
    const Iterable<IN1> &in1;
    const Iterable<IN2> &in2;

    unique_ptr<Iterator<IN1>> in1Iter;
    unique_ptr<Iterator<IN2>> in2Iter;
    const function<OUT(IN1, IN2)> &mapper;
    IN1 cur1;
    IN2 cur2;
    OUT nextElement;
    bool hasNextElement;

    void findNext() {
        if (in2Iter->hasNext()) {
            cur2 = in2Iter->next();
            nextElement = mapper(cur1, cur2);
            hasNextElement = true;
        } else {
            if (in1Iter->hasNext()) {
                cur1 = in1Iter->next();
                in2Iter = in2.iterator();
                findNext();
            } else {
                hasNextElement = false;
            }
        }
    }

public:
    ProductIterator(const Iterable<IN1> &in1, const Iterable<IN2> &in2, const function<OUT(IN1, IN2)> &mapper) : in1(
            in1), in2(in2), mapper(mapper) {
        in1Iter = in1.iterator();
        if (in1Iter->hasNext()) {
            cur1 = in1Iter->next();
            in2Iter = in2.iterator();
            findNext();
        } else {
            hasNextElement = false;
        }
    }

    virtual bool hasNext() const {
        return hasNextElement;
    }

    virtual OUT next() {
        OUT ret = nextElement;
        findNext();
        return ret;
    }
};

template<class IN1, class IN2, class OUT>
class ProductIterable : public Iterable<OUT> {
    const Iterable<IN1> &in1;
    const Iterable<IN2> &in2;
    const function<OUT(IN1, IN2)> &mapper;
public:
    ProductIterable(const Iterable<IN1> &in1, const Iterable<IN2> &in2, const function<OUT(IN1, IN2)> &mapper) : in1(
            in1), in2(in2), mapper(mapper) { }

    virtual unique_ptr<Iterator<OUT>> iterator() const {
        return unique_ptr<Iterator<OUT>>(new ProductIterator<IN1, IN2, OUT>(in1, in2, mapper));
    }
};

template<class IN1, class IN2, class OUT>
ProductIterable<IN1, IN2, OUT> product(const Iterable<IN1> &in1, const Iterable<IN2> &in2,
                                       const function<OUT(IN1, IN2)> &mapper) {
    return ProductIterable<IN1, IN2, OUT>(in1, in2, mapper);
}

template<class T, class ITERATOR>
class StdIterator : public Iterator<T> {
    const ITERATOR &begin, &end;
    ITERATOR it;

public:
    StdIterator(const ITERATOR &begin, const ITERATOR &end) : begin(begin), end(end), it(begin) { }

    virtual bool hasNext() const {
        return it != end;
    }

    virtual T next() {
        T ret = *it;
        it++;
        return ret;
    }
};

template<class T, class ITERATOR>
class StdIterable : public Iterable<T> {
    const ITERATOR &begin, &end;
public:
    StdIterable(const ITERATOR &begin, const ITERATOR &end) : begin(begin), end(end) { }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new StdIterator<T, ITERATOR>(begin, end));
    }
};

template<class T, class ITERATOR>
StdIterable<T, ITERATOR> stdIterable(const ITERATOR &begin, const ITERATOR &end) {
    return StdIterable<T, ITERATOR>(begin, end);
};

template<class T>
T aggregate(const Iterable<T> &iterable, const function<T(T, T)> &aggregator) {
    auto it = iterable.iterator();
    bool first = true;
    T ret;
    while (it->hasNext()) {
        if (first) {
            ret = it->next();
            first = false;
        } else {
            ret = aggregator(ret, it->next());
        }
    }
    return ret;
}

template<class T>
vector<T> collect(const Iterable<T> &iterable) {
    auto it = iterable.iterator();
    vector<T> vec;
    while (it->hasNext()) {
        vec.push_back(it->next());
    }
    return vec;
}

template<class T>
T aggregateMax(const Iterable<T> &iterable) {
    return aggregate<T>(iterable, [](const T &a, const T &b) { return max(a, b); });
}

template<class T>
T aggregateSum(const Iterable<T> &iterable) {
    return aggregate<T>(iterable, [](const T &a, const T &b) { return a + b; });
}

template<class T> using predicate = function<bool(T)>;

#endif


// O(sqrt(n))
bool isPrime(int64 n) {
    for (int64 i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

// O(sqrtn*logn)
set<int64> findDivisors(int64 n) {
    set<int64> ret;
    ret.insert(1);
    ret.insert(n);
    for (int64 i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            ret.insert(i);
            ret.insert(n / i);
        }
    }
    return ret;
}

template<class T>
class DivisorIterator : public Iterator<T> {
    T cur, next_, n;

public:
    DivisorIterator(T n) {
        assert(n > 0);
        this->n = n;
        cur = 0;
        next_ = 1;
    }

    virtual bool hasNext() const {
        return next_ != -1;
    }

    virtual T next() {
        cur = next_;
        if (next_ * next_ < n) {
            next_ = n / next_;
        } else if (next_ * next_ == n) {
            next_ = -1;
        } else {
            next_ = n / next_ + 1;
            bool found = false;
            while (next_ * next_ <= n) {
                if (n % next_ == 0) {
                    found = true;
                    break;
                }
                next_++;
            }
            if (!found) {
                next_ = -1;
            }
        }
        return cur;
    }
};

template<class T>
class DivisorIterable : public Iterable<T> {
    T n;
public:
    DivisorIterable(T n) {
        this->n = n;
    }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new DivisorIterator<T>(n));
    }
};

template<class T>
DivisorIterable<T> divisors(T n) {
    return DivisorIterable<T>(n);
}

template<class T>
class DigitIterator : public Iterator<T> {
    T n;

public:
    DigitIterator(T n) {
        assert(n > 0);
        this->n = n;
    }

    virtual bool hasNext() const {
        return n > 0;
    }

    virtual T next() {
        T ret = n % 10;
        n /= 10;
        return ret;
    }
};

template<class T>
class DigitIterable : public Iterable<T> {
    T n;
public:
    DigitIterable(T n) {
        this->n = n;
    }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new DigitIterator<T>(n));
    }
};

template<class T>
DigitIterable<T> digits(T n) {
    return DigitIterable<T>(n);
}

template<class T>
class RangeIterator : public Iterator<T> {
    T begin, end, step, cur;
    bool goUp;

public:
    RangeIterator(T begin, T end, T step) : begin(begin), end(end), step(step), cur(begin), goUp(begin <= end) { }

    virtual bool hasNext() const {
        return goUp ? (cur <= end) : (cur >= end);
    }

    virtual T next() {
        T ret = cur;
        if (goUp) {
            cur += step;
        } else {
            cur -= step;
        }
        return ret;
    }
};

template<class T>
class RangeIterable : public Iterable<T> {
    T begin, end, step;
public:
    RangeIterable(T begin, T end, T step) : begin(begin), end(end), step(step) { }

    virtual unique_ptr<Iterator<T>> iterator() const {
        return unique_ptr<Iterator<T>>(new RangeIterator<T>(begin, end, step));
    }
};

template<class T>
RangeIterable<T> range(T begin, T end, T step) {
    return RangeIterable<T>(begin, end, step);
}

template<class T>
RangeIterable<T> range(T begin, T end) {
    return RangeIterable<T>(begin, end, 1);
}

template<class T>
void extendedEuclid(T a, T b, T &x, T &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return;
    }
    T x2;
    extendedEuclid(b, a % b, x2, x);
    y = x2 - (a / b) * x;
}

template<class T>
T modulo(int64 a, T b) {
    T r = a % b;
    if (r < 0)
        r += b;
    return r;
}

template<class T>
T modularInverse(T a, T m) {
    T x, y;
    extendedEuclid(a, m, x, y);
    return modulo(x, m);
}

template<class T>
bool isPalindromic(T x) {
    int n = x;
    int rev = 0;
    while (n > 0) {
        int d = n % 10;
        rev = rev * 10 + d;
        n /= 10;
    }
    return x == rev;
}


int mult(int a, int b) { return a * b; }

class P4 {
public:
    void solve(std::istream &in, std::ostream &out) {
        auto all3DigitsProduct = product(range(100, 999), range(100, 999), function<int(int, int)>(mult));
        out << aggregateMax(filter(all3DigitsProduct, predicate < int > (isPalindromic<int>)));

    }
};


int main() {
    P4 solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}
